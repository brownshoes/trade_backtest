<div id="tradingview_chart" style="height: 600px; width: 100%;"></div>

<script type="text/javascript">
    let chart = null;
    let candlestickSeries = null;
    let backendIndicatorSeries = {}; // Store backend-calculated indicator series

    function initTradingViewChart() {
        // Check if library is loaded
        if (typeof LightweightCharts === 'undefined') {
            console.error('LightweightCharts library not loaded!');
            alert('Chart library not loaded. Please refresh the page.');
            return;
        }

        const container = document.getElementById('tradingview_chart');
        if (!container) {
            console.error('Chart container not found!');
            return;
        }

        // Create chart
        chart = LightweightCharts.createChart(container, {
            width: container.clientWidth,
            height: 600,
            layout: {
                background: { color: '#ffffff' },
                textColor: '#333',
            },
            grid: {
                vertLines: { color: '#e1e1e1' },
                horzLines: { color: '#e1e1e1' },
            },
            timeScale: {
                timeVisible: true,
                secondsVisible: false,
            },
        });

        // Create candlestick series
        try {
            candlestickSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderVisible: false,
                wickUpColor: '#26a69a',
                wickDownColor: '#ef5350',
            });
            console.log('Candlestick series created successfully');
            
            // Set flag that chart is initialized
            window.chartInitialized = true;
        } catch (e) {
            console.error('Error adding candlestick series:', e);
            alert('Error creating chart: ' + e.message);
            return;
        }

        // Make chart responsive
        const resizeObserver = new ResizeObserver(entries => {
            if (entries.length === 0 || entries[0].target !== container) {
                return;
            }
            const newRect = entries[0].contentRect;
            chart.resize(newRect.width, newRect.height);
        });

        resizeObserver.observe(container);

        // Check if there's pending data from a submit that happened before chart was initialized
        if (window.pendingCandleData) {
            console.log('Loading pending candle data:', window.pendingCandleData.length, 'candles');
            updateTradingViewChart(
                window.pendingCandleData, 
                window.pendingTradeMarkers,
                window.pendingIndicators
            );
            delete window.pendingCandleData;
            delete window.pendingTradeMarkers;
            delete window.pendingIndicators;
        }
    }

    // Add backend-calculated indicators (like Supertrend)
    function addBackendIndicators(indicators) {
        if (!indicators || indicators.length === 0) {
            console.log('No backend indicators to add');
            return;
        }

        console.log('Adding', indicators.length, 'backend indicators');

        // Clear existing backend indicators
        Object.values(backendIndicatorSeries).forEach(series => {
            if (series) chart.removeSeries(series);
        });
        backendIndicatorSeries = {};

        indicators.forEach(indicator => {

            console.log(indicator)
            try {
                // Ensure data exists
                if (!indicator.data) {
                    console.warn(`Indicator ${indicator.name} has no data`);
                    return;
                }

                // Parse data if it's a string
                if (typeof indicator.data === 'string') {
                    indicator.data = JSON.parse(indicator.data);
                }

                const timestamps = indicator.data.Timestamp;
                const values = indicator.data.values;

                if (!timestamps || !values) {
                    console.warn(`Indicator ${indicator.name} missing Timestamp or values`);
                    return;
                }

                // Convert to arrays if necessary
                const timestampArray = Array.isArray(timestamps) ? timestamps : Object.values(timestamps);
                const valueArray = Array.isArray(values) ? values : Object.values(values);

                // Check lengths
                if (timestampArray.length !== valueArray.length) {
                    console.warn(`Indicator ${indicator.name} timestamps and values length mismatch`);
                    return;
                }

                // Build chart data, skipping invalid values
                const chartData = [];
                for (let i = 0; i < timestampArray.length; i++) {
                    const value = valueArray[i];
                    if (value != null && !isNaN(value)) {
                        chartData.push({
                            time: Number(timestampArray[i]),
                            value: Number(value)
                        });
                    }
                }

                if (chartData.length === 0) {
                    console.warn(`No valid data for indicator ${indicator.name}`);
                    return;
                }

                // Add line series to chart
                const style = indicator.style || {};
                const series = chart.addSeries(LightweightCharts.LineSeries, {
                    color: style.color || '#2196F3',
                    lineWidth: style.lineWidth || 2,
                    title: style.title || indicator.name,
                    priceLineVisible: false,
                    lastValueVisible: true
                });


                series.setData(chartData);
                backendIndicatorSeries[indicator.name] = series;

                console.log(`âœ“ Added indicator: ${indicator.name} with ${chartData.length} points`);
            } catch (error) {
                console.error(`Error adding indicator ${indicator.name}:`, error);
            }
        });
    }


    // Global function to update chart from external data
    window.updateTradingViewChart = function(candleData, tradeMarkers, indicators) {
        console.log('updateTradingViewChart called with:', candleData.length, 'candles,', (tradeMarkers || []).length, 'markers, and', (indicators || []).length, 'indicators');
        
        if (!chart) {
            console.error('Chart object not initialized! Storing data for later.');
            window.pendingCandleData = candleData;
            window.pendingTradeMarkers = tradeMarkers;
            window.pendingIndicators = indicators;
            return;
        }
        
        if (!candlestickSeries) {
            console.error('Candlestick series not initialized! Storing data for later.');
            window.pendingCandleData = candleData;
            window.pendingTradeMarkers = tradeMarkers;
            window.pendingIndicators = indicators;
            return;
        }
        
        try {
            // Validate and filter candle data
            const validCandles = candleData.filter((candle, index) => {
                if (!candle.time || 
                    candle.open == null || 
                    candle.high == null || 
                    candle.low == null || 
                    candle.close == null) {
                    return false;
                }
                
                const open = Number(candle.open);
                const high = Number(candle.high);
                const low = Number(candle.low);
                const close = Number(candle.close);
                
                if (isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
                    return false;
                }
                
                if (high < low || high < open || high < close || low > open || low > close) {
                    return false;
                }
                
                return true;
            }).map(candle => ({
                time: Number(candle.time),
                open: Number(candle.open),
                high: Number(candle.high),
                low: Number(candle.low),
                close: Number(candle.close)
            }));
            
            console.log(`Filtered: ${candleData.length} -> ${validCandles.length} valid candles`);
            
            if (validCandles.length === 0) {
                console.error('No valid candle data to display');
                alert('No valid candle data available');
                return;
            }
            
            // Set candle data
            candlestickSeries.setData(validCandles);

            console.log(indicators)
            
            // Add backend indicators (Supertrend, etc.)
            if (indicators && indicators.length > 0) {
                addBackendIndicators(indicators);
            }
            
            // Add trade markers if provided
            if (tradeMarkers && tradeMarkers.length > 0) {
                console.log('Adding', tradeMarkers.length, 'trade markers');
                
                // Use createSeriesMarkers to add markers to the candlestick series
                LightweightCharts.createSeriesMarkers(candlestickSeries, tradeMarkers);
            }
            
            chart.timeScale().fitContent();
            console.log('Chart updated successfully with candles, markers, and indicators');
        } catch (error) {
            console.error('Error updating chart:', error);
            console.error('Error stack:', error.stack);
            alert('Failed to update chart: ' + error.message);
        }
    };
</script>