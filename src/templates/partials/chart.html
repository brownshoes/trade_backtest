<div id="tradingview_chart" style="height: 600px; width: 100%;"></div>

<script type="text/javascript">
    let chart = null;
    let candlestickSeries = null;

    function initTradingViewChart() {
        // Check if library is loaded
        if (typeof LightweightCharts === 'undefined') {
            console.error('LightweightCharts library not loaded!');
            alert('Chart library not loaded. Please refresh the page.');
            return;
        }

        const container = document.getElementById('tradingview_chart');
        if (!container) {
            console.error('Chart container not found!');
            return;
        }

        // Create chart
        chart = LightweightCharts.createChart(container, {
            width: container.clientWidth,
            height: 600,
            layout: {
                background: { color: '#ffffff' },
                textColor: '#333',
            },
            grid: {
                vertLines: { color: '#e1e1e1' },
                horzLines: { color: '#e1e1e1' },
            },
            timeScale: {
                timeVisible: true,
                secondsVisible: false,
            },
        });

        // Create candlestick series
        try {
            candlestickSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderVisible: false,
                wickUpColor: '#26a69a',
                wickDownColor: '#ef5350',
            });
            console.log('Candlestick series created successfully');
            
            // Set flag that chart is initialized
            window.chartInitialized = true;
        } catch (e) {
            console.error('Error adding candlestick series:', e);
            alert('Error creating chart: ' + e.message);
            return;
        }

        // Make chart responsive
        const resizeObserver = new ResizeObserver(entries => {
            if (entries.length === 0 || entries[0].target !== container) {
                return;
            }
            const newRect = entries[0].contentRect;
            chart.resize(newRect.width, newRect.height);
        });

        resizeObserver.observe(container);

        // Check if there's pending data from a submit that happened before chart was initialized
        if (window.pendingCandleData) {
            console.log('Loading pending candle data:', window.pendingCandleData.length, 'candles');
            updateTradingViewChart(window.pendingCandleData);
            delete window.pendingCandleData;
        }
    }

    // Global function to update chart from external data
    window.updateTradingViewChart = function(candleData) {
        console.log('updateTradingViewChart called with:', candleData.length, 'candles');
        
        if (!chart) {
            console.error('Chart object not initialized! Storing data for later.');
            window.pendingCandleData = candleData;
            return;
        }
        
        if (!candlestickSeries) {
            console.error('Candlestick series not initialized! Storing data for later.');
            window.pendingCandleData = candleData;
            return;
        }
        
        try {
            // Validate and filter candle data
            const validCandles = candleData.filter((candle, index) => {
                // Log first few for debugging
                if (index < 3) {
                    console.log(`Candle ${index}:`, candle);
                }
                
                if (!candle.time || 
                    candle.open == null || 
                    candle.high == null || 
                    candle.low == null || 
                    candle.close == null) {
                    console.warn('Skipping invalid candle:', candle);
                    return false;
                }
                
                // Check for valid numbers
                const open = Number(candle.open);
                const high = Number(candle.high);
                const low = Number(candle.low);
                const close = Number(candle.close);
                
                if (isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
                    console.warn('Skipping candle with NaN values:', candle);
                    return false;
                }
                
                // Check logical validity (high >= low, etc.)
                if (high < low || high < open || high < close || low > open || low > close) {
                    console.warn('Skipping candle with invalid OHLC logic:', candle);
                    return false;
                }
                
                return true;
            }).map(candle => ({
                time: Number(candle.time),
                open: Number(candle.open),
                high: Number(candle.high),
                low: Number(candle.low),
                close: Number(candle.close)
            }));
            
            console.log(`Filtered: ${candleData.length} -> ${validCandles.length} valid candles`);
            
            if (validCandles.length === 0) {
                console.error('No valid candle data to display');
                alert('No valid candle data available');
                return;
            }
            
            console.log('Sample valid candles:', validCandles.slice(0, 3));
            
            candlestickSeries.setData(validCandles);
            chart.timeScale().fitContent();
            console.log('Chart updated successfully');
        } catch (error) {
            console.error('Error updating chart:', error);
            console.error('Error stack:', error.stack);
            alert('Failed to update chart: ' + error.message);
        }
    };
</script>