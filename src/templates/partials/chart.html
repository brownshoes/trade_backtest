<div id="tradingview_chart" style="height: 600px; width: 100%;"></div>

<script type="text/javascript">
    let chart = null;
    let candlestickSeries = null;
    let backendIndicatorSeries = {}; // Store backend-calculated indicator series
    let markerPlugin = null; 

    function clearTradingViewChart() {
        if (!chart) return;

        if (candlestickSeries) {
            candlestickSeries.setData([]);
            // Clear markers via the plugin reference
            if (markerPlugin) {
                markerPlugin.setMarkers([]);
            }
        }

        // Clear backend indicators
        Object.values(backendIndicatorSeries).forEach(series => {
            if (series) chart.removeSeries(series);
        });
        backendIndicatorSeries = {};

        console.log('Chart and Markers cleared.');
    }

    function initTradingViewChart() {
        // Check if library is loaded
        if (typeof LightweightCharts === 'undefined') {
            console.error('LightweightCharts library not loaded!');
            alert('Chart library not loaded. Please refresh the page.');
            return;
        }

        const container = document.getElementById('tradingview_chart');
        if (!container) {
            console.error('Chart container not found!');
            return;
        }

        // Create chart
        chart = LightweightCharts.createChart(container, {
            width: container.clientWidth,
            height: 600,
            layout: {
                background: { color: '#ffffff' },
                textColor: '#333',
            },
            grid: {
                vertLines: { color: '#e1e1e1' },
                horzLines: { color: '#e1e1e1' },
            },
            timeScale: {
                timeVisible: true,
                secondsVisible: false,
            },
        });

        // Create candlestick series
        try {
            candlestickSeries = chart.addSeries(LightweightCharts.CandlestickSeries, {
                upColor: '#26a69a',
                downColor: '#ef5350',
                borderVisible: false,
                wickUpColor: '#26a69a',
                wickDownColor: '#ef5350',
            });
            console.log('Candlestick series created successfully');
            
            // Set flag that chart is initialized
            window.chartInitialized = true;
        } catch (e) {
            console.error('Error adding candlestick series:', e);
            alert('Error creating chart: ' + e.message);
            return;
        }

        // Make chart responsive
        const resizeObserver = new ResizeObserver(entries => {
            if (entries.length === 0 || entries[0].target !== container) {
                return;
            }
            const newRect = entries[0].contentRect;
            chart.resize(newRect.width, newRect.height);
        });

        resizeObserver.observe(container);

        // Check if there's pending data from a submit that happened before chart was initialized
        if (window.pendingCandleData) {
            console.log('Loading pending candle data:', window.pendingCandleData.length, 'candles');
            updateTradingViewChart(
                window.pendingCandleData, 
                window.pendingTradeMarkers,
                window.pendingIndicators
            );
            delete window.pendingCandleData;
            delete window.pendingTradeMarkers;
            delete window.pendingIndicators;
        }
    }

    // Add backend-calculated indicators (e.g. Supertrend)
    function addBackendIndicators(indicators) {
        // Remove existing indicator series
        Object.values(backendIndicatorSeries).forEach(series => {
            if (series) chart.removeSeries(series);
        });
        backendIndicatorSeries = {};

        if (!Array.isArray(indicators) || indicators.length === 0) return;

        indicators.forEach(({ name, style = {}, data }) => {
            try {
                const series = chart.addSeries(LightweightCharts.LineSeries, {
                    color: style.color ?? "#2196F3",
                    lineWidth: style.lineWidth ?? 2,
                    priceLineVisible: false,
                    lastValueVisible: false,
                });

                const { Timestamp: timestamps, values } = data;

                // Map column-oriented data to Lightweight Charts format
                const chartData = timestamps.map((time, i) =>
                    values[i] == null
                        ? { time }                 // whitespace (gap)
                        : { time, value: values[i] }
                );

                series.setData(chartData);
                backendIndicatorSeries[name] = series;

            } catch (err) {
                console.error(`Error adding backend indicator "${name}":`, err);
            }
        });
    }


    // Global function to update chart from external data
    window.updateTradingViewChart = function(candleData, tradeMarkers, indicators) {
        console.log('updateTradingViewChart called with:', candleData.length, 'candles,', (tradeMarkers || []).length, 'markers, and', (indicators || []).length, 'indicators');
        
        if (!chart) {
            console.error('Chart object not initialized! Storing data for later.');
            window.pendingCandleData = candleData;
            window.pendingTradeMarkers = tradeMarkers;
            window.pendingIndicators = indicators;
            return;
        }
        
        if (!candlestickSeries) {
            console.error('Candlestick series not initialized! Storing data for later.');
            window.pendingCandleData = candleData;
            window.pendingTradeMarkers = tradeMarkers;
            window.pendingIndicators = indicators;
            return;
        }
        
        try {
            // Validate and filter candle data
            const validCandles = candleData.filter((candle, index) => {
                if (!candle.time || 
                    candle.open == null || 
                    candle.high == null || 
                    candle.low == null || 
                    candle.close == null) {
                    return false;
                }
                
                const open = Number(candle.open);
                const high = Number(candle.high);
                const low = Number(candle.low);
                const close = Number(candle.close);
                
                if (isNaN(open) || isNaN(high) || isNaN(low) || isNaN(close)) {
                    return false;
                }
                
                if (high < low || high < open || high < close || low > open || low > close) {
                    return false;
                }
                
                return true;
            }).map(candle => ({
                time: Number(candle.time),
                open: Number(candle.open),
                high: Number(candle.high),
                low: Number(candle.low),
                close: Number(candle.close)
            }));
            
            console.log(`Filtered: ${candleData.length} -> ${validCandles.length} valid candles`);
            
            if (validCandles.length === 0) {
                console.error('No valid candle data to display');
                alert('No valid candle data available');
                return;
            }
            
            // Set candle data
            candlestickSeries.setData(validCandles);

            console.log(indicators)
            
            // Add backend indicators (Supertrend, etc.)
            if (indicators && indicators.length > 0) {
                addBackendIndicators(indicators);
            }
            
            // Add trade markers if provided
            if (tradeMarkers && tradeMarkers.length > 0) {
                if (!markerPlugin) {
                    // Create the plugin for the first time
                    markerPlugin = LightweightCharts.createSeriesMarkers(candlestickSeries, tradeMarkers);
                } else {
                    // Update existing plugin with new data (this clears the old ones)
                    markerPlugin.setMarkers(tradeMarkers);
                }
            } else if (markerPlugin) {
                // If no new markers, clear the existing ones
                markerPlugin.setMarkers([]);
            }
            
            chart.timeScale().fitContent();
            console.log('Chart updated successfully with candles, markers, and indicators');
        } catch (error) {
            console.error('Error updating chart:', error);
            console.error('Error stack:', error.stack);
            alert('Failed to update chart: ' + error.message);
        }
    };
</script>